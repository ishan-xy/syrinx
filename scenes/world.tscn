[gd_scene load_steps=4 format=3 uid="uid://evubvr3xftm7"]

[ext_resource type="PackedScene" uid="uid://csxndgunsyc70" path="res://scenes/characters/player.tscn" id="1_k5vdm"]
[ext_resource type="PackedScene" uid="uid://dsd44cbstk6jw" path="res://scenes/level_1.tscn" id="2_qxe0y"]

[sub_resource type="GDScript" id="GDScript_oqeu7"]
script/source = "extends Node2D

# FIXME: Implement manual syncronization of player's properties, implement send code too.
func send_player_data(player_id: int, position: Vector2, direction: int, animation: int):
	var data = PackedByteArray()
	data.resize(14)
	data.encode_u16(0, player_id)
	data.encode_float(2, position.x)
	data.encode_float(6, position.y)
	data.encode_u8(10, direction)
	data.encode_u8(11, animation)
	socket.send(data)

# server's port
const PORT = 3001
const MAX_DELTA = 4.0

# NOTE: `player_scene` has to be set in the ui of \"Multiplayer Syncronizer\"
@export var player_scene: PackedScene

var socket = WebSocketPeer.new()

#func _on_join_pressed():
	#peer.create_client(\"ws://127.0.0.1:\"+str(PORT)+\"/\")
	#multiplayer.multiplayer_peer = peer
	#$UI.queue_free()

func _ready():
	socket.connect_to_url(\"ws://example.com\")

func _physics_process(delta: float):
	socket.poll()
	var state = socket.get_ready_state()
	if state == WebSocketPeer.STATE_OPEN:
		while socket.get_available_packet_count():
			# NOTE: it possbly can cause issues with endianness
			var packet := socket.get_packet()
			if socket.was_string_packet():
				_on_string_data(packet)
			else:
				_on_binary_data(packet)
	elif state == WebSocketPeer.STATE_CLOSING:
		pass
	elif state == WebSocketPeer.STATE_CLOSED:
		_on_close()
		

func _on_close() -> void:
	var code = socket.get_close_code()
	var reason = socket.get_close_reason()
	print(\"WebSocket closed with code: %d, reason %s. Clean: %s\" % [code, reason, code != -1])
	# Reconnection logic
	socket = WebSocketPeer.new()
	socket.connect_to_url(\"ws://example.com\")
	set_process(true)

func _on_string_data(data: PackedByteArray) -> int:
	# TODO: implement after game's flow is decided
	return OK

func _on_binary_data(data: PackedByteArray) -> int:
	var size := data.size()
	if size == 0:
		return OK
	elif size < 2:
		return ERR_PARSE_ERROR
	var player_id := (data[0]&0xF << 8) | data[1]
	var player := get_node(str(player_id))
	match data[0] >> 4:
		0: # set user position
			if size < 10:
				return ERR_PARSE_ERROR
			if not player:
				add_player(player_id)
				player = get_node(str(player_id))
			player.position = Vector2(data.decode_float(2), data.decode_float(6))
			data = data.slice(11)
		1: # (direction + delta)
			if size < 4:
				return ERR_PARSE_ERROR
			if not player:
				return ERR_DOES_NOT_EXIST
			var short := data.decode_u16(2)
			deserialize(14, short, player)
			data = data.slice(5)
		2: # (animation data + direction + delta)
			if size < 4:
				return ERR_PARSE_ERROR
			if not player:
				return ERR_DOES_NOT_EXIST
			var short := data.decode_u16(2)
			deserialize(14, short, player)
			player.animation_type = short >> (13)
			data = data.slice(5)
		3: # remove the player form scene
			if not player:
				return ERR_DOES_NOT_EXIST
			player.queue_free()
			data = data.slice(3)
		_: # corrupt packet
			return ERR_INVALID_DATA
	return _on_binary_data(data)

func deserialize(N: int, data: int, player: CharacterBody2D) -> void:
	var TTN := (2 << N)
	var delta: float = (data & (TTN*2 - 1)) * MAX_DELTA / TTN
	var direction := (data & ((TTN*2)|(TTN*4))) >> N
	if (direction&1 == 0):
		player.position.x += (-1 * (direction>>1)&2) * delta
	else:
		player.position.y += (-1 * (direction>>1)&2) * delta
	player.movement = direction


func add_player(id):
	print(\"Called with ID: \" + str(id))
	var player := player_scene.instantiate()
	player.name = str(id)
	call_deferred(\"add_child\", player)

func exit_game(id):
	multiplayer.peer_disconnected.connect(del_player)
	del_player(id)

func del_player(id):
	rpc(\"_del_player\", id)

@rpc(\"any_peer\", \"call_local\") func _del_player(id):
	get_node(str(id)).queue_free()
"

[node name="World" type="Node2D"]
y_sort_enabled = true
position = Vector2(24, 0)

[node name="Level1" parent="." instance=ExtResource("2_qxe0y")]

[node name="Multiplayer" type="Node2D" parent="."]
y_sort_enabled = true
script = SubResource("GDScript_oqeu7")
player_scene = ExtResource("1_k5vdm")

[node name="Spawner" type="MultiplayerSpawner" parent="Multiplayer"]
_spawnable_scenes = PackedStringArray("res://scenes/characters/player.tscn")
spawn_path = NodePath("..")
spawn_limit = 10

[node name="UI" type="Control" parent="Multiplayer"]
layout_mode = 3
anchors_preset = 0
offset_left = -16.0
offset_top = -16.0
offset_right = 16.0
offset_bottom = 24.0
size_flags_vertical = 2

[node name="Host" type="Button" parent="Multiplayer/UI"]
layout_mode = 1
anchors_preset = -1
anchor_right = 1.0
anchor_bottom = 0.4
offset_right = 32.0
offset_bottom = 16.0
scale = Vector2(0.5, 0.5)
text = "HOST"
metadata/_edit_use_anchors_ = true

[node name="Join" type="Button" parent="Multiplayer/UI"]
layout_mode = 1
anchors_preset = -1
anchor_top = 0.4
anchor_right = 1.0
anchor_bottom = 0.8
offset_right = 32.0
offset_bottom = 16.0
scale = Vector2(0.5, 0.5)
text = "JOIN"
metadata/_edit_use_anchors_ = true

[node name="Camera2D" type="Camera2D" parent="Multiplayer/UI"]
position = Vector2(16, 16)
editor_draw_limits = true

[connection signal="pressed" from="Multiplayer/UI/Host" to="Multiplayer" method="_on_host_pressed"]
[connection signal="pressed" from="Multiplayer/UI/Join" to="Multiplayer" method="_on_join_pressed"]
