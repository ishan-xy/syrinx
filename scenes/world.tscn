[gd_scene load_steps=4 format=3 uid="uid://evubvr3xftm7"]

[ext_resource type="PackedScene" uid="uid://csxndgunsyc70" path="res://scenes/characters/player.tscn" id="1_k5vdm"]
[ext_resource type="PackedScene" uid="uid://dsd44cbstk6jw" path="res://scenes/level_1.tscn" id="2_qxe0y"]

[sub_resource type="GDScript" id="GDScript_oqeu7"]
script/source = "extends Node2D

# server's port
const PORT = 3001
const MAX_DELTA = 4.0

var session_id: String = \"\"
# TODO: Make this \"\", and handle empty url
var server_url: String = \"ws://example.com/\"
var socket = WebSocketPeer.new()

# NOTE: `player_scene` has to be set in the ui of \"Multiplayer Syncronizer\"
@export var player_scene: PackedScene
@export var owner_id: String

#func _on_join_pressed():
	#peer.create_client(\"ws://127.0.0.1:\"+str(PORT)+\"/\")
	#multiplayer.multiplayer_peer = peer
	#$UI.queue_free()

func _ready():
	set_physics_process(false)
	# FIXME: get the url first
	socket.connect_to_url(server_url)

func _physics_process(delta: float):
	socket.poll()
	var state = socket.get_ready_state()
	if state == WebSocketPeer.STATE_OPEN:
		while socket.get_available_packet_count():
			# NOTE: it possbly can cause issues with endianness
			var packet := socket.get_packet()
			if socket.was_string_packet():
				_on_string_data(packet)
			else:
				_on_binary_data(packet)
	elif state == WebSocketPeer.STATE_CLOSING:
		pass
	elif state == WebSocketPeer.STATE_CLOSED:
		_on_close()

#func send_player_data(player_id: int, position: Vector2, direction: int, animation: int):
	#var data = PackedByteArray()
	#data.resize(14)
	#data.encode_u16(0, player_id)
	#data.encode_float(2, position.x)
	#data.encode_float(6, position.y)
	#data.encode_u8(10, direction)
	#data.encode_u8(11, animation)
	#socket.send(data)

func _on_close() -> void:
	var code = socket.get_close_code()
	var reason = socket.get_close_reason()
	print(\"WebSocket closed with code: %d, reason %s. Clean: %s\" % [code, reason, code != -1])
	# Reconnection logic
	socket = WebSocketPeer.new()
	socket.connect_to_url(server_url)

func _on_string_data(data: PackedByteArray) -> int:
	var response = data.get_string_from_ascii()
	if response[0] == \"0\":
		if response.length() > 1:
			var obj = JSON.parse_string(response.substr(1))
			if obj == null:
				return ERR_INVALID_DATA
			session_id = obj[\"sessionID\"]
			server_url = obj[\"url\"]
			# Disable previous owner and enable the new one recieved
			owner_id = obj[\"owner\"]
		return OK
	elif response == \"1\":
		return ERR_UNAUTHORIZED
	elif response == \"2\":
		session_id = \"\"
		return ERR_UNCONFIGURED
	return ERR_INVALID_DATA

func authenticate(username: String, password: String):
	var auth_data = JSON.stringify({\"user\": username, \"pass\": password})
	socket.send_text(auth_data)

func send_session_id():
	if session_id != \"\":
		socket.send_text(session_id)
	else:
		print(\"sesison id not valid, authenticate first\")

func _on_binary_data(data: PackedByteArray) -> int:
	var size := data.size()
	if size == 0:
		return OK
	elif size < 2:
		return ERR_PARSE_ERROR
	var player_id := (data[0]&0xF << 8) | data[1]
	var player := get_node(str(player_id))
	match data[0] >> 4:
		0: # set user position
			if size < 10:
				return ERR_PARSE_ERROR
			if not player:
				add_player(player_id)
				player = get_node(str(player_id))
			player.position = Vector2(data.decode_float(2), data.decode_float(6))
			data = data.slice(11)
		1: # (direction + delta)
			if size < 4:
				return ERR_PARSE_ERROR
			if not player:
				return ERR_DOES_NOT_EXIST
			var short := data.decode_u16(2)
			deserialize(14, short, player)
			data = data.slice(5)
		2: # (animation data + direction + delta)
			if size < 4:
				return ERR_PARSE_ERROR
			if not player:
				return ERR_DOES_NOT_EXIST
			var short := data.decode_u16(2)
			deserialize(14, short, player)
			player.animation_type = short >> (13)
			data = data.slice(5)
		3: # remove the player form scene
			if not player:
				return ERR_DOES_NOT_EXIST
			player.queue_free()
			data = data.slice(3)
		_: # corrupt packet
			return ERR_INVALID_DATA
	return _on_binary_data(data)

func deserialize(N: int, data: int, player: CharacterBody2D) -> void:
	var TTN := (2 << N)
	var delta: float = (data & (TTN*2 - 1)) * MAX_DELTA / TTN
	var direction := (data & ((TTN*2)|(TTN*4))) >> N
	if (direction&1 == 0):
		player.position.x += (-1 * (direction>>1)&2) * delta
	else:
		player.position.y += (-1 * (direction>>1)&2) * delta
	player.movement = direction

func add_player(id):
	print(\"Called with ID: \" + str(id))
	var player := player_scene.instantiate()
	player.name = str(id)
	call_deferred(\"add_child\", player)

func exit_game(id):
	multiplayer.peer_disconnected.connect(del_player)
	del_player(id)

func del_player(id):
	rpc(\"_del_player\", id)

@rpc(\"any_peer\", \"call_local\") func _del_player(id):
	get_node(str(id)).queue_free()
"

[node name="World" type="Node2D"]
y_sort_enabled = true
position = Vector2(24, 0)

[node name="Level1" parent="." instance=ExtResource("2_qxe0y")]

[node name="Multiplayer" type="Node2D" parent="."]
y_sort_enabled = true
script = SubResource("GDScript_oqeu7")
player_scene = ExtResource("1_k5vdm")

[node name="Spawner" type="MultiplayerSpawner" parent="Multiplayer"]
_spawnable_scenes = PackedStringArray("res://scenes/characters/player.tscn")
spawn_path = NodePath("..")
spawn_limit = 10

[node name="UI" type="Control" parent="Multiplayer"]
layout_mode = 3
anchors_preset = 0
offset_left = -16.0
offset_top = -16.0
offset_right = 16.0
offset_bottom = 24.0
size_flags_vertical = 2

[node name="Host" type="Button" parent="Multiplayer/UI"]
layout_mode = 1
anchors_preset = -1
anchor_right = 1.0
anchor_bottom = 0.4
offset_right = 32.0
offset_bottom = 16.0
scale = Vector2(0.5, 0.5)
text = "HOST"
metadata/_edit_use_anchors_ = true

[node name="Join" type="Button" parent="Multiplayer/UI"]
layout_mode = 1
anchors_preset = -1
anchor_top = 0.4
anchor_right = 1.0
anchor_bottom = 0.8
offset_right = 32.0
offset_bottom = 16.0
scale = Vector2(0.5, 0.5)
text = "JOIN"
metadata/_edit_use_anchors_ = true

[node name="Camera2D" type="Camera2D" parent="Multiplayer/UI"]
position = Vector2(16, 16)
editor_draw_limits = true

[connection signal="pressed" from="Multiplayer/UI/Host" to="Multiplayer" method="_on_host_pressed"]
[connection signal="pressed" from="Multiplayer/UI/Join" to="Multiplayer" method="_on_join_pressed"]
